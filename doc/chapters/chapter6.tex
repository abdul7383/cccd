\chapter{Evaluation\label{cha:chapter6}}


\section{Test Environment\label{sec:eval_te_en}}
Normally in case of a concrete application there is no need to show in details how to install and configure the application but the output of this thesis is a framework which consist of many components. In order to make it easier for developers who need to deploy this framework, this section provide a details information on how to install and configure each component. Each component will be installed on a Linux machine running in the \ac{AWS} platform. Each of these machines has 7 GB RAM and 20 \ac{EC2} Compute Units (8 virtual cores with 2.5 \ac{EC2} Compute Units each) and running Ubuntu 12.04. The name of this machine within \ac{AWS} platform is \textit{High-CPU Extra Large Instance/c1.xlarge}. In order to have these machines in the same private network, these machines are created within the Amazon \ac{VPC}. 

Amazon \ac{VPC} enables provisioning of a logically isolated section of the AWS Cloud where one can launch AWS resources in a virtual network. One have complete control over the virtual networking environment, including selection of the IP address range, creation of subnets, and configuration of route tables.

Table \ref{tbl:ap_addresses} shows the IP address of each component. Thereby only the components, the app management and the content distribution have a private as well as a public IP address because these components as seen in figure \ref{fig:arch_overview} are the only components that the developer can interact with. 

\begin{table}[htb]
\begin{tabular}{|c|c|c|}
\hline 
Name & IP address \\ 
\hline 
App Management & $\begin{array}{l} \textbf{public:107.23.121.185} \\ \textbf{private:10.0.0.91}  \end{array}$ \\ 
\hline 
Repository & \textbf{10.0.0.136} \\ 
\hline 
Search Engine & \textbf{10.0.0.249} \\ 
\hline
Message Broker & \textbf{10.0.0.235} \\ 
\hline
Content Adaptation & \textbf{10.0.0.138} \\ 
\hline
Content Distribution & $\begin{array}{l} \textbf{public:107.23.180.173} \\ \textbf{private:10.0.0.139}  \end{array}$ \\ 
\hline
\end{tabular} 
\caption{IP address of each component}
\label{tbl:ap_addresses}
\end{table} 

The source code along with the documentation of the entire framework can be obtained from the following GitHub link: \url{https://github.com/abdul7383/cccd}.

\subsection{App Management\label{sec:eval_te_en_app}}
The source code of the app management component can be obtained with the following command:
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
git clone git://github.com/abdul7383/cccd.git
\end{minted}
\end{code}

In order to deploy the app management component, one needs first to install and configure the following software:

\begin{itemize}
\item{\textbf{\ac{JDK} 7:}} Installing  \ac{JDK} 7 on Ubuntu is just easy as typing the following command.% in listing \ref{lst:jdk_installation}.
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo apt-get install openjdk-7-jdk
\end{minted}
%\caption{Installing \ac{JDK} 7 on Ubuntu}
%\label{lst:jdk_installation}
\end{code}

\item{\textbf{Maven 3:}}  After downloading and extracting Maven, one needs to add the \textit{bin} directory of Maven to the Linux PATH variable. Further more one need to add the following tag within the \textit{servers} tag to the setting file of Maven \textit{apache-maven-3.0.5/conf/settings.xml}.
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{xml}
<server>
	<id>tomcat7</id>
	<username>tomcat</username>
	<password>tomcat</password>
</server>
\end{minted}
\end{code}

\item{\textbf{Tomcat 7:}} After downloading and extracting the Apache Tomcat, one need to modify the file \textit{apache-tomcat-7.0.37/conf/tomcat-users.xml} as follow in order to enable Maven to directly deploy the project into it. 
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{xml}
<?xml version='1.0' encoding='utf-8'?>
<tomcat-users>
	<role rolename="manager-script"/>
	<user username="tomcat" password="tomcat" roles="manager-script"/>
</tomcat-users>
\end{minted}
\end{code}

To start the Tomcat server from any location in Linux one also needs to add the \textit{bin} directory to the Linux PATH. The following examples updates the PATH variable for Maven and Tomcat assuming that the home directory of the user is \textit{ubuntu} and both Maven and Tomcat have been extracted to the home directory:
TODO TODO delete backslash
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
export PATH=/home/ubuntu/apache-maven-3.0.5/bin:/home/ubuntu/apache-tomcat-7.0.37/bin:\$PATH
\end{minted}
\end{code}

This sets the PATH variable only for the current Linux session but in order to have this configuration valid also for each new Linux sessions, one need to add the export line above to the end of the file \textit{/home/ubuntu/.bashrc} .

Furthermore the SSL support of Tomcat needs to be enabled and this is shown in details in the official documentation of Apache Tomcat here \cite{tomcat_ssl}.

\end{itemize}

After having all installed and configured as described above, the Tomcat server can be started with the following command:
\textit{ubuntu} and both Maven and Tomcat have been extracted to the home directory:
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
catalina.sh start
\end{minted}
\end{code} 

All debug messages of the Tomcat server can be seen in the log file \textit{apache-tomcat-7.0.37/logs/catalina.out}. 

Before deploying the app management component, one needs first to install and start all other components and then to update the IP addresses of these components in the \textit{cccd-config.xml} file of the project as described in \ref{sec:impl_repo}, \ref{sec:impl_se_en} and \ref{sec:impl_mb}. The following command will then deploy the app management component to the Tomcat server:
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd cccd/cccdAppManagement/
mvn tomcat:deploy
\end{minted}
\end{code}

It will take sometime for the first run as Maven will download and compile all needed libraries and classes.

At this point there is no user or admin for the framework and to add the first admin to the framework, one need to run the following Maven command:

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
mvn exec:java -Dexec.mainClass="de.fhg.fokus.ngni.cccd.services.AddAdmin"
\end{minted}
\end{code}

This program will ask for a username and a password and then will add these user information in a new collection called \textit{user} within a new database called \textit{users}.  After having at least one admin then the RESTful framework user management Interface \textit{/users} described in \ref{sec:des_rest_api} can be used for adding new admins or users.

\subsection{Repository/Media Store\label{sec:eval_te_en_mongo}}
The installation of MongoDB on Ubuntu is described in listing \ref{lst:mongdb_installation}, see this reference for more details \cite{MongoDb:installation}. Thereby the second command must be run in one line.  
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv 7F0CEB10
echo "deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart 
	dist 10gen" | sudo tee /etc/apt/sources.list.d/10gen.list
sudo apt-get update
sudo apt-get install mongodb-10gen
\end{minted}
\caption{Installing MongoDB on Ubuntu}
\label{lst:mongdb_installation}
\end{code}

Deploying a replication set of three MongoDB instances in order to provide a sufficient capacity for many distributed read operations can be seen in the official documentation of MongoDB here \cite{mongodb_replica_set}.

%In order to add the first admin for the framework, one need to create a database called \textit{users} and then create a new collection called \textit{user}
\subsection{Search Engine\label{sec:eval_te_se}}
After downloading  and extracting the version 0.20.4 of Elasticsearch, it can be started using:
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
bin/elasticsearch
\end{minted}
\end{code}

ElasticSearch is built using Java, and requires at least Java 6 in order to run. Therefore one needs to install the \ac{JDK} as described in subsection \ref{sec:eval_te_en_app}.

Under Unix system, the command will start the process in the background. To run it in the foreground, one need to add the -f switch to it:
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
bin/elasticsearch -f
\end{minted}
\end{code}

The most important setting for the script is the -Xmx to control the maximum allowed memory for the process, and -Xms to control the minimum allocated memory for the process. The following command starts Elasticsearch in the foreground and sets the max/min memory to 4GB and stores the index in the memory. 
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
bin/elasticsearch -f  -Xmx4g -Xms4g -Des.index.storage.type=memory
\end{minted}
\end{code}

Further configuration parameters can be seen in the setup documentation of Elasticsearch here \cite{elastic_setup}.

\subsection{Message Broker\label{sec:eval_te_mb}}
The installation of the last release of RabbitMQ is shown in the following steps:

\begin{itemize}

\item One needs to add the following line to the file \textit{/etc/apt/sources.list}:

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
deb http://www.rabbitmq.com/debian/ testing main
\end{minted}
\end{code}

\item To avoid warnings about unsigned packages, add the public key of RabbitMQ to the trusted key list using apt-key:

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
wget http://www.rabbitmq.com/rabbitmq-signing-key-public.asc
sudo apt-key add rabbitmq-signing-key-public.asc
\end{minted}
\end{code}

\item And then install the package as usual, for instance:

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo apt-get update
sudo apt-get install rabbitmq-server
\end{minted}
\end{code}

\end{itemize} 

To start or stop the server or check its status, etc., one can use the script rabbitmqctl as an administrator. 
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo rabbitmqctl status
sudo rabbitmqctl stop
sudo rabbitmqctl start
\end{minted}
\end{code}

\subsection{Content Adaptation\label{sec:eval_te_ca}}
As described in \ref{sec:des_ar_ov}, this components consist internally of the media encoder, the media segmenter and a python script called \textit{cccdCA.py}. How to install and configure these components is described below.  

The following steps are for installing FFmpeg (media encoder) along with some needed libraries \cite{ffmpeg_compile}. Some of the libraries are in the Ubuntu multiverse repository. So, one need to edit \textit{/etc/apt/sources.list} to include the multiverse repository as well.

\begin{itemize}
\item First of all, the following command install some of the dependencies needed by FFmpeg

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo apt-get update
sudo apt-get install autoconf automake build-essential checkinstall \
  git libass-dev libfaac-dev libgpac-dev libmp3lame-dev \
  libopencore-amrnb-dev libopencore-amrwb-dev librtmp-dev libspeex-dev \
  libtheora-dev libtool libvorbis-dev pkg-config texi2html zlib1g-dev
\end{minted}
\end{code}

\item{\textbf{Yasm}:} Yasm is an assembler and is recommended for x264 and FFmpeg

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
wget http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz
tar xzvf yasm-1.2.0.tar.gz
cd yasm-1.2.0
./configure
make
sudo checkinstall --pkgname=yasm --pkgversion="1.2.0" \
  --backup=no --deldoc=yes --fstrans=no --default
\end{minted}
\end{code}

\item{\textbf{x264}:} H.264 video encoder. The following commands will get the current source files, compile, and install x264.
 
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
git clone --depth 1 git://git.videolan.org/x264.git
cd x264
./configure --enable-shared
make
sudo checkinstall --pkgname=x264 \
  --pkgversion="3:$(./version.sh | awk -F'[" ]' '/POINT/{print $4"+git"$5}')" \
  --backup=no --deldoc=yes --fstrans=no --default 
\end{minted}
\end{code}

\item{\textbf{fdk-aac:}} AAC audio encoder.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
git clone --depth 1 git://github.com/mstorsjo/fdk-aac.git
cd fdk-aac
autoreconf -fiv
./configure --disable-shared
make
sudo checkinstall --pkgname=fdk-aac --pkgversion="$(date +%Y%m%d%H%M)-git" \
 --backup=no --deldoc=yes --fstrans=no --default
\end{minted}
\end{code}

\item{\textbf{libvpx:}} VP8 video encoder and decoder.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
git clone --depth 1 http://git.chromium.org/webm/libvpx.git
cd libvpx
./configure --disable-examples --disable-unit-tests
make
sudo checkinstall --pkgname=libvpx --pkgversion="1:$(date +%Y%m%d%H%M)-git" \
  --backup=no --deldoc=yes --fstrans=no --default  
\end{minted}
\end{code}

\item{\textbf{FFmpeg:}} TODO TODO delete Dolar
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
wget http://ffmpeg.org/releases/ffmpeg-0.9.2.tar.bz2
tar -xvvf ffmpeg-0.9.2.tar.bz2 
cd ffmpeg-0.9.2

./configure --enable-gpl --enable-libass --enable-libfaac \
  --enable-libmp3lame --enable-libopencore-amrnb --enable-libopencore-amrwb \
  --enable-libspeex --enable-librtmp --enable-libtheora --enable-libvorbis \
  --enable-libvpx --enable-libx264 --enable-nonfree --enable-version3
make
sudo checkinstall --pkgname=ffmpeg --pkgversion="0.9.2" \
  --backup=no --deldoc=yes --fstrans=no --default
sudo ldconfig $
\end{minted}
\end{code}
\end{itemize}

The following steps describes how to compile the media segmenter/distributor.

\begin{itemize}

\item The source code can be obtained with following command.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
git clone git://github.com/abdul7383/cccd.git
\end{minted}
\end{code}

\item The following command install some of the dependencies needed by the media segmenter/distributor and the python script \textit{cccdCA.py}.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo apt-get install ruby rubygem python-pika
\end{minted}
\end{code}

\item For compiling the media segmenter/distributor, the following commands are needed.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd ~/cccd/cccdContentAdaption/hls
make
\end{minted}
\end{code}

\end{itemize} 

The python script \textit{cccdCA.py} and its configuration \textit{cccdCA.conf} are located in the directory \textit{~/cccd/cccdContentAdaption}. Most important configuration in \textit{ cccdCA.conf}  is the FTP transfer profile. One need to set the IP address and the user credentials of the FTP server, which is installed on the content distribution component \ref{sec:eval_te_cd}. The default configuration contains 8 encoding profiles shown below. These encoding profiles are for devices with 16x9 or 4x3 screen resolution and they are in four different streams bitrate.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
[ 'cell_16x9_150k', 'cell_16x9_240k', 'wifi_16x9_440k', 'wifi_16x9_640k' , 'cell_4x3_150k', 'cell_4x3_240k', 'wifi_4x3_440k', 'wifi_4x3_640']
\end{minted}
\label{lst:encoding_profiles}
\end{code}

Finally to start the content adaptation component, one need simply to run the following commands.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd ~/cccd/cccdContentAdaption
sudo ./cccdCA.py
\end{minted}
\end{code}

Before running the python script, the parameter \textit{message\_broker\_ip} needs to be set to the IP address of the message broker component.

\subsection{Content Distribution\label{sec:eval_te_cd}}
As described in \ref{sec:impl_cdn}, the content distribution component consists internally of two components, which are a python script called \textit{cccdCD.py} and the open source project NginX as a \ac{HTTP} server. The installation of the NginX server is described below.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
wget http://nginx.org/download/nginx-1.2.7.tar.gz
tar -xvvf nginx-1.2.7.tar.gz 
cd nginx-1.2.7/
sudo apt-get update
sudo apt-get install gcc make
./configure --with-http_secure_link_module \
  --without-http_rewrite_module --without-http_gzip_module
make
sudo make install
\end{minted}
\end{code}

The following command starts Nginx in the background.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo /usr/local/nginx/sbin/nginx
\end{minted}
\end{code}

The following commands are for installing and running the python script \textit{cccdCD.py}.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
wget https://raw.github.com/abdul7383/cccd/master/cccdContentDistribution/cccdCDN.py
chmod +x cccdCDN.py
sudo apt-get install python-pika
sudo ./cccdCDN.py
\end{minted}
\end{code}

Before running the python script, the parameter \textit{message\_broker\_ip} needs to be set to the IP address of the message broker component.

\section{Test Scenarios\label{sec:eval__te_sc}}
For evaluating the framework, the next two subsections provide a usability test in which a deployment scenario of a specific application is described and a performance test in which the document REST interface \textit{/app/{appName}/collections/{collectionName}/doc} is tested.

\subsection{Usability\label{seq:eval_usab}}
As a usability test, the first scenario mentioned in section \ref{sec:req_sce} will be deployed and configured in the framework. Thereby this test will only show how the \ac{JSON} requests and its responses looks like and also how is the the interaction between the components.

For sending custom \ac{HTTP} requests and showing their responses, the Advance Rest Client described here \ref{sec:impl_advanced_rest_cl} is used.

After creating the first admin user as described at the end of this subsection \ref{sec:eval_te_en_app}, the admin user creates a new user without admin rights with the following request.
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://admin:pass@107.23.121.185:8443/cccd/users?username=user1
  &password=pass1&email=user1@email.com&role=2
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"ok": "1",
"debug": "user: user1 created"
}
\end{minted}
\end{code}

From now on, the created user \textit{user1} will be used for all following requests.

The following request is for creating a new application named \textit{vod}. Thereby it contains as a payload a secret word \textit{secret1} and a list of video encoding profiles so that each uploaded video will be available in these profiles. Listing \ref{lst:encoding_profiles} lists all encoding profiles.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://user1:pass1@107.23.121.185:8443/cccd/app/vod
\end{minted}
Payload:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"secret":"secret1",
"profiles":["cell_16x9_150k","wifi_16x9_640k"],

}
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"ok": "1",
"debug": "app: vod created"
}
\end{minted}
\end{code}
 
Figure \ref{fig:newApp} shows how the request is processed. A new database within the repository is created. Thereby a new table called \textit{user} is created, which contains the users along with their rights, and also another table called \textit{conf} which contains all configuration parameters that belongs to this app.

Furthermore a notification message is sent to the message broker component to forward this message to the content distribution component. This message notifies the content distribution component about the new created app so that it creates a new directory for this new app within the HTTP server and secures it with the secure word provided by the user while creating the app.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.6]{flows/newAppFlow.png}\\
  \caption{Creating a new app}
  \label{fig:newApp}
\end{figure}

For checking if the app \textit{vod} was created successfully, the following request lists all apps that belongs to the user \textit{user1}.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
GET https://user1:pass1@107.23.121.185:8443/cccd/app/
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"data": [
	"vod"
],
"ok": "1"
}
\end{minted}
\end{code}
 
For uploading files, i.e. videos or images, to the new created app, one needs first to create a bucket, which will hold these files, within this app. The following request creates a new bucket called \textit{bucket1}.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://user1:pass1@107.23.121.185:8443/cccd/app/vod/buckets/bucket1
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"ok": "1",
"debug": "bucket: bucket1 created"
}
\end{minted}
\end{code}

Listing all buckets within an app can be done with the following request.
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
GET https://user1:pass1@107.23.121.185:8443/cccd/app/vod/buckets
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"data": [
	"bucket1"
],
"ok": "1"
}
\end{minted}
\end{code}

Now the bucket \textit{bucket1} is created but before uploading files to it, one needs to create a collection within the app \textit{vod} to hold the context/metadata of the file. The following request creates a new collection called \textit{videos}. Thereby an empty index is automatically created in the search engine component. Figure \ref{fig:newCollection} illustrate how the request is processed internally in the framework.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://user1:pass1@107.23.121.185:8443/cccd/app/vod/collections/videos
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"ok": "1",
"debug": "collection: videos and an empty index created"
}
\end{minted}
\end{code}

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.6]{flows/newCollectionFlow.png}\\
  \caption{Creating a new collection}
  \label{fig:newCollection}
\end{figure}

To configure the app \textit{vod} to send a new message notification to a queue called \textit{contetnt\_adaptation} for each new inserted document to the collection \textit{videos}, the following request is needed. Thereby one can configure the app to send the message notification to more than one queue for supporting more services like M2M context enrichment or Subscribe/Notification.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://user1:pass1@107.23.121.185:8443/cccd/app/vod
\end{minted}
Payload:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"videos" : ["contetnt_adaptation"]
}
\end{minted}
\end{code}

The following request list all configurations for the app \textit{vod}.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
GET https://user1:pass1@107.23.121.185:8443/cccd/app/vod
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"data": {
	"profiles": [
		"cell_16x9_150k",
		"wifi_16x9_640k"
	],
	"secret": "secret1",
	"videos": [
		"contetnt_adaptation"
	]
},
"ok": "1"
}
\end{minted}
\end{code}

Before adding data to the collection \textit{videos}, the data fields should be mapped to a proper object, i.e. string, integer, date, array or geo\_point and also one can specify if a specific field will be indexed or stored in the search engine. At the beginning, the mapping of the created collection is empty, which can be seen with the following request.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
GET https://user1:pass1@107.23.121.185:8443/cccd/app/vod/collections/videos/mapping
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"ok": "0",
"debug": "no mapping found"
}
\end{minted}
\end{code}

As soon as any data get inserted to the collection, the mapping get updated automatically but it can not be updated anymore, i.e. setting a specific filed to be indexed or stored in the search engine. Therefore the mapping for each field should be set before adding any data to the collection, see the official documentation of the search engine Elasticsearch for further information on the mapping interface \cite{elastic_mapping}. The following request updates the mapping of the collection \textit{videos}.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
PUT https://user1:pass1@107.23.121.185:8443/cccd/app/vod/collections/videos/mapping
\end{minted}
Payload:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
    "videos" : {
        "properties" : {
            "user" : {"type" : "string", "store" : "yes", "index" : "not_analyzed"},
            "titel" : {"type" : "string", "store" : "yes"},
            "description" : {"type" : "string", "store" : "yes"},
            "tags" : {"type" : "string", "store" : "yes"},
            "uploadTime" : {"type" : "date", "store" : "yes"},
            "location" : {"type" : "geo_point", "store" : "yes"},
            "fileLink" : {
                "type" : "object",
                "properties" : {
                    "app" : {"type" : "string", "store" : "yes", "index" : "not_analyzed"},
                    "bucket" : {"type" : "string", "store" : "yes", "index" : "not_analyzed"},
                    "objectid" : {"type" : "string", "store" : "yes", "index" : "not_analyzed"}
                }
            }
        }
    }
}
\end{minted}
\end{code}

Now listing the mapping of the collection \textit{video} will show all fields withe their respective types, see following request.
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
GET https://user1:pass1@107.23.121.185:8443/cccd/app/vod/collections/videos/mapping
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"data": {
	"properties": {
		"description": {
			"type": "string",
			"store": "yes"
		},
		"fileLink": {
			"properties": {
				"app": {
					"type": "string",
					"index": "not_analyzed",
					"store": "yes",
					"omit_norms": true,
					"index_options": "docs"
				},
				"bucket": {
					"type": "string",
					"index": "not_analyzed",
					"store": "yes",
					"omit_norms": true,
					"index_options": "docs"
				},
				"objectid": {
					"type": "string",
					"index": "not_analyzed",
					"store": "yes",
					"omit_norms": true,
					"index_options": "docs"
				}
			}
		},
		"location": {
			"type": "geo_point",
			"store": "yes"
		},
		"tags": {
			"type": "string",
			"store": "yes"
		},
		"titel": {
			"type": "string",
			"store": "yes"
		},
		"uploadTime": {
			"type": "date",
			"store": "yes",
			"format": "dateOptionalTime"
		},
		"user": {
			"type": "string",
			"index": "not_analyzed",
			"store": "yes",
			"omit_norms": true,
			"index_options": "docs"
		}
	}
},
"ok": "1"
}
\end{minted}
\end{code}

Now the bucket, the collection and its mapping are ready, one can now upload the videos and their related context. For having users, who are developers that need to use the created app for only uploading, searching, downloading, or streaming videos, the following request add a read-only user to the created app \textit{vod}. Thereby the user to be added to the app user list must be already a registered user in the framework (already created through \textit{/cccd/users}).

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
PUT https://user1:pass1@107.23.121.185:8443/cccd/app/vod
  /users?username=user2&readonly=true
\end{minted}
\end{code}

To check if the user has been added successfully to the user list of the app \textit{vod}, the following request is needed.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
GET https://user1:pass1@107.23.121.185:8443/cccd/app/vod
  /users
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"data": [
	{
		"username": "user1",
		"readOnly": false
	},
	{
		"username": "user2",
		"readOnly": true
	}
],
"ok": "1"
}
\end{minted}
\end{code}

Now uploading a video to the new created app is done in two steps, one need first to upload the video file to a bucket within the app. The bucket \textit{bucket1}, which is created above, will be used in the following request. Thereby the \textit{objectid} of the uploaded file is returned in the response, which will be then used for ensuring the correlation between the video file and its context/metadata.
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://user1:pass1@107.23.121.185:8443/cccd/app/vod
  /buckets/bucket1/files
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"data": {
	"app": "appName",
	"bucket": "bucket1",
	"objectid": "515b2e2ae4b0da706f84c1a7"
	},
"ok": "1"
}
\end{minted}
\end{code}

The video file is now saved within the bucket \textit{bucket1}. The second step is to upload the context/metadata of the video file along with the file-link within the app \textit{vod}. These two steps are needed for uploading videos and in the same way two other videos have been uploaded, which has been recorded in Berlin Tempelhof and in Frankfurt am Main Bahnhofsviertel. 
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://user1:pass1@107.23.121.185:8443/cccd/app/vod
  /collections/videos/doc
\end{minted}
Payload:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
	"title" : "Brandenburger Tor New year 2013 ",
	"description" : "Berlin Brandenburger Tor - New year 2013",
	"tags" : "Berlin,Brandenburger Tor,new year 2013,fireworks",
	"uploadTime" : "2013-01-15T14:12:12",
	"location" : "52.516275,13.377227",
	"user" : "abdul",
	"fileLink" : {
		"app" : "vod",
		"bucket" : "bucket1", 
		"objectid" : "515b2e2ae4b0da706f84c1a7"
	}
}
\end{minted}
\end{code}

These two steps are needed for uploading videos and in the same way two other videos have been uploaded, which has been recorded in Berlin Tempelhof and in Frankfurt am Main Bahnhofsviertel. 
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
	"title": "Happy New Year 2013 Berlin Tempelhof ",
	"location": "52.469635,13.385658",
	"description": "New Year 2013 Silvester in Berlin Tempelhof",
	"fileLink": {
		"app": "vod",
		"bucket": "bucket1",
		"objectid": "515b0a99e4b0262de3bb2c7d"
	},
	"uploadTime": "2013-01-02T14:12:12",
	"tags": "Berlin,Tempelhof, new year 2013,firework",
	"user": "tom"
}
{
	"title": "Frankfurt Germany Fireworks New Years 2013",
	"location": "50.108806,8.664432",
	"description": "From our balcony the fireworks for 2013",
	"fileLink": {
		"app": "vod",
		"bucket": "bucket1",
		"objectid": "515ad4afe4b08cc9e8560330"
	},
	"uploadTime": "2013-01-05T14:12:12",
	"tags": "frankfurt,,new year 2013,firework",
	"user": "frank"
}
\end{minted}
\end{code}

After a short time, depending of how big the video files are, the framework will update the context/metadata of each uploaded video file with the links for each \ac{HLS} encoded videos based on the encoding profiles which have been set while creating the app (\textit{cell\_16x9\_150k,wifi\_16x9\_640k}).

The following request is for searching all videos which hast been captured within a maximum distance of 10 km from Potsdamer Platz(lat,lon: 52.509693,13.376218) in Berlin. Thereby the response must be ordered by the distance.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://user1:pass1@107.23.121.185:8443/cccd/app/vod
  /collections/videos/search
\end{minted}
Payload:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
    "sort" : [
        {
            "_geo_distance" : {
                "location" : "52.509693,13.376218",
                "order" : "asc",
                "unit" : "km"
            }
        }
    ],
    "query": {
        "filtered" : {
            "query" : {
                "match_all" : {}
            },
            "filter" : {
                "geo_distance" : {
                    "distance" : "10km",
                    "location" : "52.509693,13.376218"
                }
            }
        }
    }
}
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"data": {
	"hits": {
		"total": 2,
		"max_score": null,
		"hits": [
			{
				"_index": "vod_videos",
				"_type": "videos",
				"_id": "515b4008e4b0da706f84c1a9",
				"_score": null,
				"_source": {
					"title": "Brandenburger Tor New year 2013 ",
					"location": "52.516275,13.377227",
					"description": "Berlin Brandenburger Tor - New year 2013",
					"fileLink": {
						"app": "vod",
						"bucket": "bucket1",
						"objectid": "515b2e2ae4b0da706f84c1a7"
					},
					"uploadTime": "2013-01-15T14:12:12",
					"tags": "Berlin,Brandenburger Tor, new year 2013,firework",
					"user": "abdul"
				},
				"sort": [
					0.7350631627891678
				]
			},
			{
				"_index": "vod_videos",
				"_type": "videos",
				"_id": "515b429ce4b0da706f84c1aa",
				"_score": null,
				"_source": {
					"title": "Happy New Year 2013 Berlin Tempelhof ",
					"location": "52.469635,13.385658",
					"description": "New Year 2013 Silvester in Berlin Tempelhof",
					"fileLink": {
						"app": "vod",
						"bucket": "bucket1",
						"objectid": "515b0a99e4b0262de3bb2c7d"
					},
					"uploadTime": "2013-01-02T14:12:12",
					"tags": "Berlin,Tempelhof, new year 2013,firework",
					"user": "tom",
					"hls_videos": {
						"cell_16x9_150k":
							"http://107.23.180.173/vod/515b4008e4b0da706f84c1a9/cell_16x9_150k.m3u8",
						"wifi_16x9_640k":
							"http://107.23.180.173/vod/515b4008e4b0da706f84c1a9/wifi_16x9_640k.m3u8",
						"multi_rate":
							"http://107.23.180.173/vod/515b4008e4b0da706f84c1a9/multi.m3u8"
					}
				},
				"sort": [
					4.499869967538772
				]
			}	
		]
	}
},
"ok": "1"
}
\end{minted}
\end{code}
For each matched video in the response above, a \textit{sort} tag that contains the distance of the matched video from the searched location is returned. Furthermore the matched videos above contain a new tag \textit{hls\_videos} and they can be used to start streaming the video file directly on a mobile device, i.e. iPad, iPhone and etc. These video links are secured and can be only accessed through a security token and how to generate this token is shown here \cite{nginx:securelink}. Thereby the secret word is the secret word provided while creating the app.

\subsection{Performance\label{seq:eval_perf}}
The performance evaluation can not be done easily for the entire framework, therefore only one REST interface is tested, which has interactions with more components. The interface to be tested is the document interface the \textit{/app/appName/collections/collectionName/doc}. It has interactions with the repository, search engine and the message broker component.%been chosed some components of the framework will be tested. The components app management, repository and the search engine will be tested. Thereby the interfaces to be tested are the \textit{/app/appName/collections/collectionName/doc} and the \textit{/app/appName/collections/collectionName/search}. 

The used tool for testing the interface is the open source tool Apache ab and for drawing the graphs the open source tool Gnuplot. 

The Tests is done in two scenarios, the first one with only one instance of the app management component and the second one is with two instances of the app management and also an \ac{AWS} load balancer to distribute the incoming traffic across both app management instances. Only the operations CREATE(POST) and READ(GET) are tested.

\paragraph{GET}
The following Apache ab command is used for testing the interface, where the -n option is the number of requests to perform and the -c option is the number of multiple requests to make(concurrency level). The -n option is set always to 10000 requests in the following tests and the -c option is changed in every test.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
ab -A user1:pass1 -n 10000 -c 50 -g doc_50.dat 
 http://10.0.0.91:8080/cccd/app/vod/collections/videos/doc/515b4008e4b0da706f84c1a9
\end{minted}
\end{code}

\begin{itemize}
\item{\textbf{Without load balancer:}} Figure \ref{fig:get_without_load} shows three tests with the -c option set to 50, 70 and 100. Thereby only the test with the concurrency level set to 50 is succeed without any failed requests. By setting the -c option to 70 there were total of 4996 failed requests and by setting it to 100 total of 7722 failed requests.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.4]{img/Without_LoadBalancer_100_70_50_GET}\\
  \caption{GET tests without load balancer}
  \label{fig:get_without_load}
\end{figure}

\item{\textbf{With load balancer:}} Figure \ref{fig:get_with_load} shows four tests with the -c option set to 200, 250, 300 and 400. The expected result was that both instances would be capable to serve the double traffic as the test above(-c 50) with one instance without failed requests, namely concurrency level set to 100. But the two instances with the load balancer are unexpectedly capable to serve up to a concurrency level of 400 without a noticeable failed requests(less than 100 requests).

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.4]{img/With_LoadBalancer_200_250_300_400_GET}\\
  \caption{GET tests with load balancer}
  \label{fig:get_with_load}
\end{figure}
\end{itemize}

\paragraph{POST}
The following Apache ab command is used for testing the CREATE operation. The payload of the POST request is saved in a file called \textit{post.json}. 
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
ab -A user1:pass1 -T "application/json" -p post.json -n 10000 -c 50 -g doc_50.dat 
 http://10.0.0.91:8080/cccd/app/vod/collections/videos/doc
\end{minted}
\end{code}
The file \textit{post.json} contains:
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
	"title": "Happy New Year 2013 Berlin Tempelhof ",
	"location": "52.469635,13.385658",
	"description": "New Year 2013 Silvester in Berlin Tempelhof",
	"fileLink": {
		"app": "vod",
		"bucket": "bucket1",
		"objectid": "515b0a99e4b0262de3bb2c7d"
	},
	"uploadTime": "2013-01-02T14:12:12",
	"tags": "Berlin,Tempelhof, new year 2013,firework",
	"user": "tom"
}
\end{minted}
\end{code}

\begin{itemize}
\item{\textbf{Without load balancer:}} Figure \ref{fig:post_without_load} shows three tests with the -c option set to 50, 70 and 100. Thereby only the test with the concurrency level set to 50 is succeed without any failed requests. By setting the -c option to 70 there were total of 5167 failed requests and by setting it to 100 total of 9040 failed requests.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.4]{img/Without_LoadBalancer_100_70_50_POST}\\
  \caption{POST tests without load balancer}
  \label{fig:post_without_load}
\end{figure}

\item{\textbf{With load balancer:}} Figure \ref{fig:get_with_load} shows three tests with the -c option set to 200, 250 and 300. The  failed requests by the concurrency level 200 and 250 are less than 100 requests and by the concurrency level 300 the failed requests are 213.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.4]{img/With_LoadBalancer_200_250_300_POST}\\
  \caption{GET tests with load balancer}
  \label{fig:get_with_load}
\end{figure}
\end{itemize}