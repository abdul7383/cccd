\chapter{Evaluation\label{cha:chapter6}}
The evaluation of the implemented prototype of the framework will be explained in this chapter. Thereby section \ref{sec:eval_te_en}  provides an overview of the test environment along with a detail information on how to install and configure each component and section \ref{sec:eval__te_sc} evaluates the framework by means of two test scenarios which are a usability and performance test.

\section{Test Environment\label{sec:eval_te_en}}
Normally, in the case of a concrete application there is no need to show in detail how to install and configure the application. However the result of this thesis is a framework which consists of many components. In order to make it easier for developers who need to deploy this framework, this section provides detailed information on how to install and configure each component. Each component will be installed on a Linux machine running in the \ac{AWS} platform. Each of these machines has 7 GB RAM and 20 \ac{EC2} Compute Units (8 virtual cores with 2.5 \ac{EC2} Compute Units each) and running Ubuntu 12.04. The name of this machine within \ac{AWS} platform is \textit{High-CPU Extra Large Instance/c1.xlarge}. In order to have these machines in the same private network, these machines are created within the Amazon \ac{VPC}. 

Amazon \ac{VPC} enables provisioning of a logically isolated section of the AWS Cloud where one can launch AWS resources in a virtual network. One can have complete control over the virtual networking environment, including the selection of the IP address range, creation of subnets, and configuration of route tables.

Table \ref{tbl:ap_addresses} shows the IP address of each component. Thereby, only the components, the app management and the content distribution have a private as well as a public IP address because these components as seen in figure \ref{fig:arch_overview} are the only components that the developer can interact with. 

\begin{table}[htb]
\begin{tabular}{|c|c|c|}
\hline 
Name & IP address \\ 
\hline 
App Management & $\begin{array}{l} \textbf{public:107.23.121.185} \\ \textbf{private:10.0.0.91}  \end{array}$ \\ 
\hline 
Repository & \textbf{10.0.0.136} \\ 
\hline 
Search Engine & \textbf{10.0.0.249} \\ 
\hline
Message Broker & \textbf{10.0.0.235} \\ 
\hline
Content Adaptation & \textbf{10.0.0.138} \\ 
\hline
Content Distribution & $\begin{array}{l} \textbf{public:107.23.180.173} \\ \textbf{private:10.0.0.139}  \end{array}$ \\ 
\hline
\end{tabular} 
\caption{IP addresses of test machines}
\label{tbl:ap_addresses}
\end{table} 

The source code along with the documentation of the entire framework can be obtained from the following GitHub link: \url{https://github.com/abdul7383/cccd}.

\subsection{App Management\label{sec:eval_te_en_app}}
The source code of the app management component can be obtained with the following command:
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
git clone git://github.com/abdul7383/cccd.git
\end{minted}
\end{code}

In order to deploy the app management component, one needs firstly to install and configure the following software:

\begin{itemize}
\item{\textbf{\ac{JDK} 7:}} Installing  \ac{JDK} 7 on Ubuntu is just easy as typing the following command.% in listing \ref{lst:jdk_installation}.
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo apt-get install openjdk-7-jdk
\end{minted}
%\caption{Installing \ac{JDK} 7 on Ubuntu}
%\label{lst:jdk_installation}
\end{code}

\item{\textbf{Maven 3:}}  After downloading and extracting Maven, one needs to add the \textit{bin} directory of Maven to the Linux PATH variable. Furthermore one needs to add the following tag within the \textit{servers} tag to the setting file of Maven \textit{apache-maven-3.0.5/conf/settings.xml}.
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{xml}
<server>
	<id>tomcat7</id>
	<username>tomcat</username>
	<password>tomcat</password>
</server>
\end{minted}
\end{code}

\item{\textbf{Tomcat 7:}} After downloading and extracting the Apache Tomcat, one needs to modify the file \textit{apache-tomcat-7.0.37/conf/tomcat-users.xml} as follows in order to enable Maven to directly deploy the project into it. 
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{xml}
<?xml version='1.0' encoding='utf-8'?>
<tomcat-users>
	<role rolename="manager-script"/>
	<user username="tomcat" password="tomcat" roles="manager-script"/>
</tomcat-users>
\end{minted}
\end{code}

To start the Tomcat server from any location in Linux, one also needs to add the \textit{bin} directory to the Linux PATH. The following example updates the PATH variable for Maven and Tomcat assuming that the home directory of the user is \textit{ubuntu} and both Maven and Tomcat have been extracted to the home directory:

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
export PATH=/home/ubuntu/apache-maven-3.0.5/bin:/home/ubuntu/apache-tomcat-7.0.37/bin:$PATH
\end{minted}
\end{code}

This sets the PATH variable only for the current Linux session, however, in order to have this configuration valid for each new Linux sessions, one needs to add the export line above at the end of the file \textit{/home/ubuntu/.bashrc} .

Furthermore, the SSL support of Tomcat needs to be enabled and this is shown in detail in the official documentation of Apache Tomcat here \cite{tomcat_ssl}.

\end{itemize}

After having installed and configured everything as described above, the Tomcat server can be started with the following command:
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
catalina.sh start
\end{minted}
\end{code} 

All debug messages of the Tomcat server can be seen in the log file \textit{apache-tomcat-7.0.37/logs/catalina.out}. 

Before deploying the app management component, one needs firstly to install and start all other components and then to update the IP addresses of these components in the \textit{cccd-config.xml} file of the project as described in \ref{sec:impl_repo}, \ref{sec:impl_se_en} and \ref{sec:impl_mb}. The following command will then deploy the app management component to the Tomcat server:
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd cccd/cccdAppManagement/
mvn tomcat:deploy
\end{minted}
\end{code}

It will take sometime for the first run, as Maven will download and compile all needed libraries and classes.

At this point, there is no user or administrator for the framework and in order to add the first administrator to the framework, one needs to run the following Maven command:

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
mvn exec:java -Dexec.mainClass="de.fhg.fokus.ngni.cccd.services.AddAdmin"
\end{minted}
\end{code}

This program will ask for a username and password and then will add this user information in a new collection called \textit{user} within a new database called \textit{users}.  After having at least one administrator then the RESTful framework user management interface \textit{/users} described in \ref{sec:des_rest_api} can be used for adding new administrators or users.

\subsection{Repository/Media Store\label{sec:eval_te_en_mongo}}
The installation of MongoDB on Ubuntu is described in the listing \ref{lst:mongdb_installation}, see this reference for more details \cite{MongoDb:installation}.  
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv 7F0CEB10
echo "deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart \
	dist 10gen" | sudo tee /etc/apt/sources.list.d/10gen.list
sudo apt-get update
sudo apt-get install mongodb-10gen
\end{minted}
\caption{Installing MongoDB on Ubuntu}
\label{lst:mongdb_installation}
\end{code}

In order to provide a sufficient capacity for many distributed read operations, a replication set of three MongoDB instances needs to be deployed. This can be seen in the official documentation of MongoDB here \cite{mongodb_replica_set}.

%In order to add the first admin for the framework, one need to create a database called \textit{users} and then create a new collection called \textit{user}
\subsection{Search Engine\label{sec:eval_te_se}}
After downloading  and extracting the version 0.20.6 of Elasticsearch, it can be started using:
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
bin/elasticsearch
\end{minted}
\end{code}

ElasticSearch is built using Java, and requires at least Java 6 in order to run. Therefore, one needs to install the \ac{JDK} as described in subsection \ref{sec:eval_te_en_app}.

Under Unix system, the command will start the process in the background. To run it in the foreground, one need to add the -f switch to it:
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
bin/elasticsearch -f
\end{minted}
\end{code}

The most important setting for the script is the -Xmx to control the maximum allowed memory for the process and -Xms to control the minimum allocated memory for the process. The following command starts Elasticsearch in the foreground and sets the max/min memory to 4GB and stores the index in the memory. 
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
bin/elasticsearch -f  -Xmx4g -Xms4g -Des.index.storage.type=memory
\end{minted}
\end{code}

Further configuration parameters can be seen in the setup documentation of Elasticsearch here \cite{elastic_setup}.

\subsection{Message Broker\label{sec:eval_te_mb}}
The installation of the last release of RabbitMQ is shown in the following steps:

\begin{itemize}

\item One needs to add the following line to the file \textit{/etc/apt/sources.list}:

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
deb http://www.rabbitmq.com/debian/ testing main
\end{minted}
\end{code}

\item To avoid warnings about unsigned packages, add the public key of RabbitMQ to the trusted key list using apt-key:

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
wget http://www.rabbitmq.com/rabbitmq-signing-key-public.asc
sudo apt-key add rabbitmq-signing-key-public.asc
\end{minted}
\end{code}

\item Next install the package as usual, for instance:

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo apt-get update
sudo apt-get install rabbitmq-server
\end{minted}
\end{code}

\end{itemize} 

To start or stop the server or check its status, etc., one can use the script rabbitmqctl as an administrator. 
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo rabbitmqctl status
sudo rabbitmqctl stop
sudo rabbitmqctl start
\end{minted}
\end{code}

\subsection{Content Adaptation\label{sec:eval_te_ca}}
As described in \ref{sec:des_ar_ov}, this component consists internally of the media encoder, the media segmenter and a python script called \textit{cccdCA.py}. The following describes how to install and configure these components.  

The following steps are for installing FFmpeg (media encoder) along with some essential libraries \cite{ffmpeg_compile}. Some of the libraries are in the Ubuntu multiverse repository. Therfore, one needs to edit \textit{/etc/apt/sources.list} to include the multiverse repository as well.

\begin{itemize}
\item First of all, the following command will install some of the dependencies needed by FFmpeg

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo apt-get update
sudo apt-get install autoconf automake build-essential checkinstall \
  git libass-dev libfaac-dev libgpac-dev libmp3lame-dev \
  libopencore-amrnb-dev libopencore-amrwb-dev librtmp-dev libspeex-dev \
  libtheora-dev libtool libvorbis-dev pkg-config texi2html zlib1g-dev
\end{minted}
\end{code}

\item{\textbf{Yasm}:} Yasm is an assembler and is recommended for x264 and FFmpeg

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
wget http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz
tar xzvf yasm-1.2.0.tar.gz
cd yasm-1.2.0
./configure
make
sudo checkinstall --pkgname=yasm --pkgversion="1.2.0" \
  --backup=no --deldoc=yes --fstrans=no --default
\end{minted}
\end{code}

\item{\textbf{x264}:} H.264 video encoder. The following commands will get the current source files, compile, and install x264.
 
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
git clone --depth 1 git://git.videolan.org/x264.git
cd x264
./configure --enable-shared
make
sudo checkinstall --pkgname=x264 \
  --pkgversion="3:$(./version.sh | awk -F'[" ]' '/POINT/{print $4"+git"$5}')" \
  --backup=no --deldoc=yes --fstrans=no --default 
\end{minted}
\end{code}

\item{\textbf{fdk-aac:}} AAC audio encoder.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
git clone --depth 1 git://github.com/mstorsjo/fdk-aac.git
cd fdk-aac
autoreconf -fiv
./configure --disable-shared
make
sudo checkinstall --pkgname=fdk-aac --pkgversion="$(date +%Y%m%d%H%M)-git" \
 --backup=no --deldoc=yes --fstrans=no --default
\end{minted}
\end{code}

\item{\textbf{libvpx:}} VP8 video encoder and decoder.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
git clone --depth 1 http://git.chromium.org/webm/libvpx.git
cd libvpx
./configure --disable-examples --disable-unit-tests
make
sudo checkinstall --pkgname=libvpx --pkgversion="1:$(date +%Y%m%d%H%M)-git" \
  --backup=no --deldoc=yes --fstrans=no --default  
\end{minted}
\end{code}

\item{\textbf{FFmpeg:}}
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
wget http://ffmpeg.org/releases/ffmpeg-0.9.2.tar.bz2
tar -xvvf ffmpeg-0.9.2.tar.bz2 
cd ffmpeg-0.9.2

./configure --enable-gpl --enable-libass --enable-libfaac \
  --enable-libmp3lame --enable-libopencore-amrnb --enable-libopencore-amrwb \
  --enable-libspeex --enable-librtmp --enable-libtheora --enable-libvorbis \
  --enable-libvpx --enable-libx264 --enable-nonfree --enable-version3
make
sudo checkinstall --pkgname=ffmpeg --pkgversion="0.9.2" \
  --backup=no --deldoc=yes --fstrans=no --default
sudo ldconfig 
\end{minted}
\end{code}
\end{itemize}

The following steps describe how to compile the media segmenter/distributor.

\begin{itemize}

\item The source code can be obtained with following command.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
git clone git://github.com/abdul7383/cccd.git
\end{minted}
\end{code}

\item The following command will install some of the dependencies needed by the media segmenter/distributor and the python script \textit{cccdCA.py}.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo apt-get install ruby rubygems python-pip python-dev build-essential requests
sudo pip install pika
\end{minted}
\end{code}

\item In order to compile the media segmenter/distributor, the following commands are needed.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd ~/cccd/cccdContentAdaption/hls
make
sudo cp *.rb /usr/local/lib/site-ruby/1.8/
\end{minted}
\end{code}

\end{itemize} 

The python script \textit{cccdCA.py} and its configuration \textit{cccdCA.conf} are located in the directory \textit{~/cccd/cccdContentAdaption}. The most important configuration in \textit{ cccdCA.conf}  is the FTP transfer profile. One needs to set the IP address and the user credentials of the FTP server, which is installed on the content distribution component \ref{sec:eval_te_cd}. The default configuration contains 8 encoding profiles shown below. These encoding profiles are for devices with 16x9 or 4x3 screen resolution and they are in four different streams bitrate.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
[ 'cell_16x9_150k', 'cell_16x9_240k', 'wifi_16x9_440k', 'wifi_16x9_640k' ,
   'cell_4x3_150k', 'cell_4x3_240k', 'wifi_4x3_440k', 'wifi_4x3_640']
\end{minted}
\caption{List of supported encoding profiles}
\label{lst:encoding_profiles}
\end{code}

Finally, to start the content adaptation component, one needs simply to run the following commands.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd ~/cccd/cccdContentAdaption
sudo ./cccdCA.py
\end{minted}
\end{code}

Before running the python script, the parameter \textit{message\_broker\_ip} needs to be set to the IP address of the message broker component.

\subsection{Content Distribution\label{sec:eval_te_cd}}
As described in \ref{sec:impl_cdn}, the content distribution component consists internally of two components, which are a python script called \textit{cccdCD.py} and the open source project NginX as a \ac{HTTP} server. The installation of the NginX server is described below.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
wget http://nginx.org/download/nginx-1.2.7.tar.gz
tar -xvvf nginx-1.2.7.tar.gz 
cd nginx-1.2.7/
sudo apt-get update
sudo apt-get install gcc make  libpcre3 libpcre3-dev proftpd-basic
./configure --with-http_secure_link_module \
   --without-http_gzip_module
make
sudo make install
sudo mkdir /usr/local/nginx/locations
\end{minted}
\end{code}

The following commands are for the configuration of the ftp server, where the uid 1002 is the user id of the created user \textit{cdnuser}, which can be get with '\textit{id -u cdnuser}'.
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo useradd cdnuser -d /usr/local/nginx/html/ -s /bin/false
sudo passwd cdnuser
sudo chown -R cdnuser:cdnuser /usr/local/nginx/html/
cd /etc/proftpd/
sudo ftpasswd --passwd --name cdnuser --uid 1002 --home /usr/local/nginx/html/ --shell /bin/false
\end{minted}
\end{code}

One needs also to add the following lines to the end of the proftpd configuration file \textit{/etc/proftpd/proftpd.conf}
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
DefaultRoot ~
AuthOrder                      mod_auth_file.c  mod_auth_unix.c
AuthUserFile /etc/proftpd/ftpd.passwd
AuthPAM off
RequireValidShell off
\end{minted}
\end{code}

In the configuration file \textit{/usr/local/nginx/conf/nginx.conf} one need to add following two lines to the \textit{server} block.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
root /usr/local/nginx/html;
include /usr/local/nginx/locations/*.conf;
\end{minted}
\end{code}
 
The following command starts Nginx in the background.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
sudo /usr/local/nginx/sbin/nginx
\end{minted}
\end{code}

The following commands are for the installing and the running of the python script \textit{cccdCD.py}.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
cd
wget https://raw.github.com/abdul7383/cccd/master/cccdContentDistribution/cccdCDN.py
chmod +x cccdCDN.py
sudo apt-get install python-pip
sudo pip install pika
sudo ./cccdCDN.py
\end{minted}
\end{code}

Before running the python script, the parameter \textit{message\_broker\_ip} needs to be set to the IP address of the message broker component.

\section{Test Scenarios\label{sec:eval__te_sc}}
In order to evaluate the framework, the next two subsections provide a usability test in which a deployment scenario of a specific application is described and a performance test in which the document REST interface \textit{/app/{appName}/collections/{collectionName}/doc} is tested.

\subsection{Usability\label{seq:eval_usab}}
As a usability test, the first scenario mentioned in section \ref{sec:req_sce} will be deployed and configured in the framework. Thereby, this test will only show how the \ac{JSON} requests and what its responses look like. It also shows the interaction between the components.

In order to send custom \ac{HTTP} requests and show their responses, the Advance Rest Client described here \ref{sec:impl_advanced_rest_cl} is used.

After creating the first administrator as described at the end of this subsection \ref{sec:eval_te_en_app}, the administrator creates a new user without administration rights with the following request.
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://admin:pass@107.23.121.185:8443/cccd/users?username=user1
  &password=pass1&email=user1@email.com&role=2
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"ok": "1",
"debug": "user: user1 created"
}
\end{minted}
\end{code}

From now on, the created user \textit{user1} will be used for all following requests.

The following request is for creating a new application named \textit{vod}. Within the payload will be contained, a secret word \textit{secret1} and a list of video encoding profiles, so that each uploaded video will be available in these profiles. Listing \ref{lst:encoding_profiles} lists all encoding profiles.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://user1:pass1@107.23.121.185:8443/cccd/app/vod
\end{minted}
Payload:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"secret":"secret1",
"profiles":["cell_16x9_150k","wifi_16x9_640k"]
}
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"ok": "1",
"debug": "app: vod created"
}
\end{minted}
\end{code}
 
Figure \ref{fig:newApp} shows how the request is processed. A new database within the repository is created. Thereby, a new table called \textit{user} is created, which contains all the users and their rights, and also another table called \textit{conf} which contains all configuration parameters that belongs to this app.

Furthermore, a notification message is sent to the message broker component to forward this message to the content distribution component. This message notifies the content distribution component about the newly created app, so that it creates a new directory for this new app within the HTTP server and secures it with the secure word provided by the user while creating the app.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.6]{flows/newAppFlow.png}\\
  \caption{Creating a new app}
  \label{fig:newApp}
\end{figure}

For checking if the app \textit{vod} was created successfully, the following request lists all apps that belongs to the user \textit{user1}.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
GET https://user1:pass1@107.23.121.185:8443/cccd/app/
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"data": [
	"vod"
],
"ok": "1"
}
\end{minted}
\end{code}
 
In order to upload files, i.e. videos or images, to the newly created app, one needs firstly to create a bucket, which will hold these files, within this app. The following request creates a new bucket called \textit{bucket1}.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://user1:pass1@107.23.121.185:8443/cccd/app/vod/buckets/bucket1
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"ok": "1",
"debug": "bucket: bucket1 created"
}
\end{minted}
\end{code}

Listing all buckets within an app can be done with the following request.
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
GET https://user1:pass1@107.23.121.185:8443/cccd/app/vod/buckets
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"data": [
	"bucket1"
],
"ok": "1"
}
\end{minted}
\end{code}

Now the bucket \textit{bucket1} is created. However, before uploading files to it, one needs to create a collection within the app \textit{vod} to hold the context/metadata of the file. The following request creates a new collection called \textit{videos}. Thereby, an empty index is automatically created in the search engine component. Figure \ref{fig:newCollection} illustrates how the request is processed internally in the framework.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://user1:pass1@107.23.121.185:8443/cccd/app/vod/collections/videos
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"ok": "1",
"debug": "collection: videos and an empty index created"
}
\end{minted}
\end{code}

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.6]{flows/newCollectionFlow.png}\\
  \caption{Creating a new collection}
  \label{fig:newCollection}
\end{figure}

In order to configure the app \textit{vod} to send a new message notification to a queue called \textit{contetnt\_adaptation} for each new inserted document to the collection \textit{videos}, the following request is needed. Thereby, one can configure the app to send the message notification to more than one queue for supporting more services like M2M context enrichment or Subscribe/Notification.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://user1:pass1@107.23.121.185:8443/cccd/app/vod
\end{minted}
Payload:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"videos" : ["contetnt_adaptation"]
}
\end{minted}
\end{code}

The following request lists all configurations for the app \textit{vod}.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
GET https://user1:pass1@107.23.121.185:8443/cccd/app/vod
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"data": {
	"profiles": [
		"cell_16x9_150k",
		"wifi_16x9_640k"
	],
	"secret": "secret1",
	"videos": [
		"contetnt_adaptation"
	]
},
"ok": "1"
}
\end{minted}
\end{code}

Before adding data to the collection \textit{videos}, the data fields should be mapped to a proper object, i.e. string, integer, date, array or geo\_point. One can also specify if a specific field will be indexed or stored in the search engine. At first, the mapping of the created collection is empty, which can be seen with the following request.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
GET https://user1:pass1@107.23.121.185:8443/cccd/app/vod/collections/videos/mapping
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"ok": "0",
"debug": "no mapping found"
}
\end{minted}
\end{code}

As soon as some data is inserted into the collection, the mapping is automatically updated, however it can not be updated anymore, i.e. setting a specific filed to be indexed or stored in the search engine. Therefore, the mapping for each field should be set before adding any data to the collection, see the official documentation of the search engine Elasticsearch for further information on the mapping interface \cite{elastic_mapping}. The following request updates the mapping of the collection \textit{videos}.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
PUT https://user1:pass1@107.23.121.185:8443/cccd/app/vod/collections/videos/mapping
\end{minted}
Payload:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"videos" : {
	"properties" : {
		"user" : {"type" : "string", "store" : "yes", "index" : "not_analyzed"},
		"titel" : {"type" : "string", "store" : "yes"},
		"description" : {"type" : "string", "store" : "yes"},
		"tags" : {"type" : "string", "store" : "yes"},
		"uploadTime" : {"type" : "date", "store" : "yes"},
		"location" : {"type" : "geo_point", "store" : "yes"},
		"fileLink" : {
			"type" : "object",
			"properties" : {
				"app" : {"type" : "string", "store" : "yes", "index" : "not_analyzed"},
				"bucket" : {"type" : "string", "store" : "yes", "index" : "not_analyzed"},
				"objectid" : {"type" : "string", "store" : "yes", "index" : "not_analyzed"}
			}
		}
	}
}
}
\end{minted}
\end{code}

Now listing the mapping of the collection \textit{video} will show all fields with their respective types, see the following request.
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
GET https://user1:pass1@107.23.121.185:8443/cccd/app/vod/collections/videos/mapping
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"data": {
	"properties": {
		"description": {
			"type": "string",
			"store": "yes"
		},
		"fileLink": {
			"properties": {
				"app": {
					"type": "string",
					"index": "not_analyzed",
					"store": "yes",
					"omit_norms": true,
					"index_options": "docs"
				},
				"bucket": {
					"type": "string",
					"index": "not_analyzed",
					"store": "yes",
					"omit_norms": true,
					"index_options": "docs"
				},
				"objectid": {
					"type": "string",
					"index": "not_analyzed",
					"store": "yes",
					"omit_norms": true,
					"index_options": "docs"
				}
			}
		},
		"location": {
			"type": "geo_point",
			"store": "yes"
		},
		"tags": {
			"type": "string",
			"store": "yes"
		},
		"titel": {
			"type": "string",
			"store": "yes"
		},
		"uploadTime": {
			"type": "date",
			"store": "yes",
			"format": "dateOptionalTime"
		},
		"user": {
			"type": "string",
			"index": "not_analyzed",
			"store": "yes",
			"omit_norms": true,
			"index_options": "docs"
		}
	}
},
"ok": "1"
}
\end{minted}
\end{code}

Now the bucket, the collection and its mapping are all ready and one can now upload the videos and their related context. In order to have users who are developers or service providers that need to use the created app for only uploading, searching, downloading, or streaming videos, the following request adds a read-only user to the created app \textit{vod}. Thereby, the user to be added to the app user list must already be  a registered user in the framework (previously created through \textit{/cccd/users}).

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
PUT https://user1:pass1@107.23.121.185:8443/cccd/app/vod
  /users?username=user2&readonly=true
\end{minted}
\end{code}

To check if the user has been added successfully to the user list of the app \textit{vod}, the following request is needed.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
GET https://user1:pass1@107.23.121.185:8443/cccd/app/vod/users
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"data": [
	{
		"username": "user1",
		"readOnly": false
	},
	{
		"username": "user2",
		"readOnly": true
	}
],
"ok": "1"
}
\end{minted}
\end{code}

Next, uploading a video to the new created app can be done in two steps. Firstly one needs to upload the video file to a bucket within the app. The bucket \textit{bucket1}, which is created above, will be used in the following request. Thereby ,the \textit{objectid} of the uploaded file is returned in the response, which will be then used for ensuring the correlation between the video file and its context/metadata.
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://user1:pass1@107.23.121.185:8443/cccd/app/vod
  /buckets/bucket1/files
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"data": {
	"app": "vod",
	"bucket": "bucket1",
	"objectid": "515b2e2ae4b0da706f84c1a7"
},
"ok": "1"
}
\end{minted}
\end{code}

The video file is now saved within the bucket \textit{bucket1}. The second step is to upload the context/metadata of the video file along with the file-link within the app \textit{vod}.
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://user1:pass1@107.23.121.185:8443/cccd/app/vod
  /collections/videos/doc
\end{minted}
Payload:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
	"title" : "Brandenburger Tor New year 2013 ",
	"description" : "Berlin Brandenburger Tor - New year 2013",
	"tags" : "Berlin,Brandenburger Tor,new year 2013,fireworks",
	"uploadTime" : "2013-01-15T14:12:12",
	"location" : "52.516275,13.377227",
	"user" : "abdul",
	"fileLink" : {
		"app" : "vod",
		"bucket" : "bucket1", 
		"objectid" : "515b2e2ae4b0da706f84c1a7"
	}
}
\end{minted}
\end{code}

These two steps are needed for uploading videos and in the same way two other videos have been uploaded, which have been recorded in Berlin Tempelhof and Frankfurt am Main Bahnhofsviertel. 
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
	"title": "Happy New Year 2013 Berlin Tempelhof ",
	"location": "52.469635,13.385658",
	"description": "New Year 2013 Silvester in Berlin Tempelhof",
	"fileLink": {
		"app": "vod",
		"bucket": "bucket1",
		"objectid": "515b0a99e4b0262de3bb2c7d"
	},
	"uploadTime": "2013-01-02T14:12:12",
	"tags": "Berlin,Tempelhof, new year 2013,firework",
	"user": "tom"
}
{
	"title": "Frankfurt Germany Fireworks New Years 2013",
	"location": "50.108806,8.664432",
	"description": "From our balcony the fireworks for 2013",
	"fileLink": {
		"app": "vod",
		"bucket": "bucket1",
		"objectid": "515ad4afe4b08cc9e8560330"
	},
	"uploadTime": "2013-01-05T14:12:12",
	"tags": "frankfurt,,new year 2013,firework",
	"user": "frank"
}
\end{minted}
\end{code}

After a short time, depending of how big the video files are, the framework will update the context/metadata of each uploaded video file with the links for each \ac{HLS} encoded videos based on the encoding profiles which have been set while creating the app (\textit{cell\_16x9\_150k,wifi\_16x9\_640k}).

The following request is for searching for all videos which have been captured within a maximum distance of 10 km from Potsdamer Platz(lat,lon: 52.509693,13.376218) in Berlin. Thereby, the response must be ordered by the distance.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
POST https://user1:pass1@107.23.121.185:8443/cccd/app/vod
  /collections/videos/search
\end{minted}
Payload:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
    "sort" : [
        {
            "_geo_distance" : {
                "location" : "52.509693,13.376218",
                "order" : "asc",
                "unit" : "km"
            }
        }
    ],
    "query": {
        "filtered" : {
            "query" : {
                "match_all" : {}
            },
            "filter" : {
                "geo_distance" : {
                    "distance" : "10km",
                    "location" : "52.509693,13.376218"
                }
            }
        }
    }
}
\end{minted}
Response:
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
"data": {
	"hits": {
		"total": 2,
		"max_score": null,
		"hits": [
			{
				"_index": "vod_videos",
				"_type": "videos",
				"_id": "515b4008e4b0da706f84c1a9",
				"_score": null,
				"_source": {
					"title": "Brandenburger Tor New year 2013 ",
					"location": "52.516275,13.377227",
					"description": "Berlin Brandenburger Tor - New year 2013",
					"fileLink": {
						"app": "vod",
						"bucket": "bucket1",
						"objectid": "515b2e2ae4b0da706f84c1a7"
					},
					"uploadTime": "2013-01-15T14:12:12",
					"tags": "Berlin,Brandenburger Tor, new year 2013,firework",
					"user": "abdul"
				},
				"sort": [
					0.7350631627891678
				]
			},
			{
				"_index": "vod_videos",
				"_type": "videos",
				"_id": "515b429ce4b0da706f84c1aa",
				"_score": null,
				"_source": {
					"title": "Happy New Year 2013 Berlin Tempelhof ",
					"location": "52.469635,13.385658",
					"description": "New Year 2013 Silvester in Berlin Tempelhof",
					"fileLink": {
						"app": "vod",
						"bucket": "bucket1",
						"objectid": "515b0a99e4b0262de3bb2c7d"
					},
					"uploadTime": "2013-01-02T14:12:12",
					"tags": "Berlin,Tempelhof, new year 2013,firework",
					"user": "tom",
					"hls_videos": {
						"cell_16x9_150k":
							"http://107.23.180.173/vod/515b4008e4b0da706f84c1a9/cell_16x9_150k.m3u8",
						"wifi_16x9_640k":
							"http://107.23.180.173/vod/515b4008e4b0da706f84c1a9/wifi_16x9_640k.m3u8",
						"multi_rate_16x9":
							"http://107.23.180.173/vod/515b4008e4b0da706f84c1a9/multi_16x9.m3u8"
					}
				},
				"sort": [
					4.499869967538772
				]
			}	
		]
	}
},
"ok": "1"
}
\end{minted}
\end{code}
For each matched video in the response above, a \textit{sort} tag that contains the distance of the matched video from the searched location is returned. Furthermore, the matched videos above contain a new tag \textit{hls\_videos} and they can be used to start streaming the video file directly on a mobile device, i.e. iPad, iPhone and etc. These video links are secured and can be only accessed through a security token and the generation of this token is shown here \cite{nginx:securelink}. Thereby the secret word is the secret word provided while creating the app.

\subsection{Performance\label{seq:eval_perf}}
It is not easy to do a performance evaluation for the entire framework, therefore, only one REST interface is tested, which has interactions with more components. The interface to be tested is the document interface \textit{/app/appName/collections/collectionName/doc}. This interface has interactions with the repository, search engine and the message broker component.%been chosed some components of the framework will be tested. The components app management, repository and the search engine will be tested. Thereby the interfaces to be tested are the \textit{/app/appName/collections/collectionName/doc} and the \textit{/app/appName/collections/collectionName/search}. 

The tool used for testing the interface is the open source tool Apache ab and for drawing the graphs the open source tool Gnuplot. 

The tests are done in two scenarios, the first one with only one instance of the app management component and the second one  with two instances of the app management and also an \ac{AWS} load balancer to distribute the incoming traffic across both app management instances. Only the operations CREATE(POST) and READ(GET) are tested.

\paragraph{GET}
The following Apache ab command is used for testing the interface, where the -n option is the number of requests to perform and the -c option is the number of multiple requests to make(concurrency level). The -n option is set always to 10000 requests in the following tests and the -c option is changed in every test.

\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
ab -A user1:pass1 -n 10000 -c 50 -g doc_50.dat 
 http://10.0.0.91:8080/cccd/app/vod/collections/videos/doc/515b4008e4b0da706f84c1a9
\end{minted}
\end{code}

\begin{itemize}
\item{\textbf{Without load balancer:}} Figure \ref{fig:get_without_load} shows three tests with the -c option set to 50, 70 and 100. Thereby, only the test with the concurrency level set to 50 was successful without any failed requests. By setting the -c option to 70 there were a total of 4996 failed requests and by setting it to 100 a total of 7722 failed requests.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.4]{img/Without_LoadBalancer_100_70_50_GET}\\
  \caption{GET tests without load balancer}
  \label{fig:get_without_load}
\end{figure}

\item{\textbf{With load balancer:}} Figure \ref{fig:get_with_load} shows four tests with the -c option set to 200, 250, 300 and 400. The expected result was that both instances were capable of serving double traffic as the test above(-c 50) with one instance, without a failed request, with the concurrency level set to 100. However, the two instances with the load balancer were unexpectedly capable of serving up to a concurrency level of 400 without noticeable failed requests(less than 100 requests).

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.4]{img/With_LoadBalancer_200_250_300_400_GET}\\
  \caption{GET tests with load balancer}
  \label{fig:get_with_load}
\end{figure}
\end{itemize}

\paragraph{POST}
The following Apache ab command is used for testing the CREATE operation. The payload of the POST request is saved in the file called \textit{post.json}. 
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{console}
ab -A user1:pass1 -T "application/json" -p post.json -n 10000 -c 50 -g doc_50.dat 
 http://10.0.0.91:8080/cccd/app/vod/collections/videos/doc
\end{minted}
\end{code}
The file \textit{post.json} contains:
\begin{code}
\begin{minted}[frame=single,tabsize=2,fontsize=\footnotesize]{json}
{
	"title": "Happy New Year 2013 Berlin Tempelhof ",
	"location": "52.469635,13.385658",
	"description": "New Year 2013 Silvester in Berlin Tempelhof",
	"fileLink": {
		"app": "vod",
		"bucket": "bucket1",
		"objectid": "515b0a99e4b0262de3bb2c7d"
	},
	"uploadTime": "2013-01-02T14:12:12",
	"tags": "Berlin,Tempelhof, new year 2013,firework",
	"user": "tom"
}
\end{minted}
\end{code}

\begin{itemize}
\item{\textbf{Without load balancer:}} Figure \ref{fig:post_without_load} shows three tests with the -c option set to 50, 70 and 100. Thereby only the test with the concurrency level set to 50 was successful without any failed requests. By setting the -c option to 70 there were a total of 5167 failed requests and by setting it to 100 a total of 9040 failed requests.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.4]{img/Without_LoadBalancer_100_70_50_POST}\\
  \caption{POST tests without load balancer}
  \label{fig:post_without_load}
\end{figure}

\item{\textbf{With load balancer:}} Figure \ref{fig:get_with_load} shows three tests with the -c option set to 200, 250 and 300. The  failed requests within the concurrency level 200 and 250 were less than 100 requests and within the concurrency level 300 the failed requests were 213.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.4]{img/With_LoadBalancer_200_250_300_POST}\\
  \caption{POST tests with load balancer}
  \label{fig:get_with_load}
\end{figure}
\end{itemize}