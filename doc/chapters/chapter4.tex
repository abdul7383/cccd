\chapter{Design\label{cha:chapter4}}
Against the background of the requirements described previously in chapter 3, this chapter provides a design concept for the framework. Section 4.1 will describe a basic architectural concept of the framework to be refined in section 4.2 and 4.3 which provide a more detailed description of the framework's components and their interactions. The final section reviews the parity between the requirements from chapter 3 and the corresponding architectural components. 
        


\section{Architecture Overview\label{sec:des_ar_ov}}
Figure \ref{fig:arch_overview} shows an architecture overview of the framework, which consists mainly of six components. The components with three dots(...) in them means that the framework can be later extended with new components for adding new services to the framework like SUBSCRIBE/NOTIFICATION etc.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.6]{arch_overview.png}\\
  \caption{Architecture Overview}
  \label{fig:arch_overview}
\end{figure}

%Before diving into the details of each component, the following subsections illustrate some work flows that have to be processed in order to process a request, i.e. creating a new application, adding a new content or searching for a content.
%
%\subsection{Create App-Work Flow}
%As illustrated in figure bla, these steps are needed for creating a new application:
%
%\begin{itemize}
%\item developer sends a request for creating a new app to the App Management API along with his credentials and containing the name for the new app and a secret to be later used to get the stored contents
%\item App Management checks if the credentials are correct
%\item App Management checks if the new app name already exist
%\item AppM creates a database in the repository with the given app name and sets its owner to the developer who created it.
%\item AppM send a message to the Worker Queue and thereby announce the creation of a new app with the given name and the secret
%\item Content Distribution servers which listens to the Worker Queue create a virtual space for the new app and securing it with the secret word provided while creation the new app
%\end{itemize}

\section{Framework Components\label{sec:des_com}}
The App Management component is the main entry for each developer to interact with the framework. These developers needs to authenticate them self in order to use the framework and therefore a appropriate User Management is needed. Furthermore the Repository/Media Store is needed in order to store the data an the multimedia files. For efficient data discovery, the Search Engine component  is required. The task of the Content Adaptation component is to convert the stored files to other formats and then upload these converted files to the Content Distribution component which then serve them to various devices.

Those components are described in more details in the next subsections.
 
\subsection{App Management\label{sec:des_repo}}

The App Management component is the core of the entire framework and it interacts with almost all components in the framework. The following subsections describe the design decision that have been made for implementing this component.

\subsubsection{JSON}
The data format to interact with the framework is JSON. It has been chosen due its low-overhead comparing with XML and it is also the data format for many of the known NoSQL systems, which one of them will be used in the framework.
 
\subsubsection{User Management \label{sec:des_user_man}}
In order to allow only registered developers to use the framework, a User Management design concept is described in the following.

The User Management component provides two levels of management. The first one is to provide a role based user management for using the entire framework. The role can be either an admin or a normal user - which here means a developer who use the framework. Both admin and user are allowed to use the framework i.e. creating new applications, modeling the app and storing, getting or deleting contents etc. Only admins can add a new admin or user.

The second level of the User Management component provides a mechanism for managing who can modify an existing app or store/get contents from this app. The user who created the app is theoretically the owner of it and he is the only one who is allowed to add other users for using his app. Thereby he can add users with the same rights as his rights, meaning they can modify the whole app, deleting contents etc., or add other users, who only allowed to store/get/search contents. For example this is useful for a developer, who has deployed/configured a new app and then lets a service provider to use his app by only storing, getting, searching the contents in this app. 

\subsubsection{REST Interfaces} For interacting with the outside world, a standard and well defined interface is needed. The decision for choosing REST as an API interface is due to its flexibility, simplicity, less bandwidth usage and very easy way to scale for large deployment, see section \ref{sec:back_soap_vs_rest} for more detailed comparison.

Following paragraphs describes the various interfaces needed in order to be able to use the framework:

\paragraph{Framework User Management Interface /users :} This interface provide the first level of user management described in \ref{sec:des_user_man}. Only admins are allowed to use this interface for managing users.

\begin{itemize}
\item \textbf{Create:} The method \textit{addUser} requires following parameters, \textit{username}, \textit{password}, \textit{firstname}, \textit{lastname}, \textit{email} and \textit{role}.  The role parameter is an integer and specify if the user has ADMIN - 1 - or USER - 2 - role. These parameters is passed through an URI parameters, see following example for adding a new admin.

\begin{code}
\begin{minted}[frame=single]{console}
POST https://user1:pass@107.23.121.185:8080/cccd/
/users?username=frank&password=pass2&firstname=frank&
lastname=schulz&email=frank21@yahoo.de&role=1
\end{minted}
\end{code}

\item \textbf{Delete:} The method \textit{deleteUser} requires only \textit{username} as a parameter. It is not allowed to delete the \textit{username} if he is the last admin in the framework, else no one can admin it.

\begin{code}
\begin{minted}[frame=single]{console}
DELETE https://user1:pass@107.23.121.185:8080/cccd/
/users?username=frank
\end{minted}
\end{code}

\end{itemize}


\paragraph{App interface \textit{/app/} :} This interface provides the four CRUD operation, which described bellow, to allow developers to interact with there apps.

\begin{itemize}
\item \textbf{Create(POST):} This method \textit{createApp} creates a new app and it requires a name and global configuration parameters for the app. These configuration parameters can be for example a mandatory secret word to be later used for securing the contents which belongs to this app or a list of video formats, which will be then used to transcode each uploaded video within this app in order to support various devices i.e. iPad, iPhone, PC and etc. Listing \ref{lst:new_app_json} shows a JSON example for creating a new app with \textbf{vod1} as a name.

\begin{code}
\begin{minted}[frame=single]{console}
POST https://user1:pass@107.23.121.185:8080/cccd/app/vod1
\end{minted}
Payload:
\begin{minted}[frame=single]{json}
{
"secret":"pass123",
"video_formats":"cell_4x3_150k,wifi_4x3_640k,wifi_4x3_1240k"
}
\end{minted}
Response:
\begin{minted}[frame=single]{json}
{
"ok": "1",
"debug": "app: vod1 created"
}
\end{minted}
\caption{Creating a new app}
\label{lst:new_app_json}
\end{code}

\item \textbf{Read(GET):} There are two methods in this App Interface, which can be consumed through a HTTP GET, first one \textit{listApps} is for listing all apps which belongs to the user, see listing \ref{lst:listing_apps} as an example. 

\begin{code}
\begin{minted}[frame=single]{console}
GET https://user1:pass@107.23.121.185:8080/cccd/app
\end{minted}
Response:
\begin{minted}[frame=single]{json}
{
"data":["app3","vod","vod1","app1"],
"ok":"1"
}
\end{minted}
\caption{Listing all apps which belong to a user}
\label{lst:listing_apps}
\end{code}


The second method \textit{checkAppStatus} returns data that reflects the amount of storage used and data contained in a specific app, as well as object, collection, and index counters. This data can be used to check and track the state and storage of a specific app, the example below will returns these data for an app called \textit{vod1}.

\begin{code}
\begin{minted}[frame=single]{console}
GET https://user1:pass@107.23.121.185:8080/cccd/app/vod1
\end{minted}
%Response:
%\begin{minted}[frame=single]{json}
%{
%"data":["app3","vod","vod1","app1"],
%"ok":"1"
%}
%\end{minted}
%\caption{Listing all apps which belong to a user}
%\label{lst:listing_apps}
\end{code}

\item \textbf{Update(PUT):}  This method \textit{updateApp} is for updating/adding the configuration parameters of the app. i.e changing the secret word or adding new configuration parameters which can be needed from other components, i.e. adding the user credentials for a Justin.TV account in order to stream a video to it.

\item \textbf{Delete(DELETE):} This method \textit{deleteApp} delete the app along with its related contents which might be in the Repository, Media Store or in the Content Distributor component.

\end{itemize}

\paragraph{App User Management Interface /app/{appName}/users :} This interface provide the second level user management described in \ref{sec:des_user_man}. The users table is saved on the repository within the app. In order to add a user to an app with WRITE or only READ rights, he must be already registered in the framework as a valid user.

\begin{itemize}
\item \textbf{Create:} The method \textit{addUser} takes following parameters, \textit{appName}, \textit{username} which needs to be added to the app and which rights will it has \textit{readonly}. The \textit{username} and \textit{readonly} parameters are passed through URI parameters, see following example.

\begin{code}
\begin{minted}[frame=single]{console}
POST https://user1:pass@107.23.121.185:8080/cccd/app/vod1
/users?username=frank&readonly=true
\end{minted}
\end{code}

\item \textbf{Delete:} The method \textit{deleteUser} takes two parameters, namely \textit{appName} and the name of the user \textit{username} which needs to be deleted from the app. It is not allowed to delete the \textit{username} if he is the last user who has WRITE rights, else no one else can admin the app.

\begin{code}
\begin{minted}[frame=single]{console}
DELETE https://user1:pass@107.23.121.185:8080/cccd/app/vod1
/users?username=frank
\end{minted}
\end{code}

\end{itemize}

\paragraph{Collection Interface /app/{appName}/collections/ :} The collection within an app can be compared with tables in SQL systems and it contains the real data, i.e. the metadata for a content. This interface provide only Create, Read, and Delete operations. 

%There is two types of collections interface within an app, namely \textit{/collections/} and \textit{/acollections/}. This interface \textit{/collections/} is for managing data, which does not require any kind of transcoding/transforming for contents, i.e. a collection which contain the friend list of an end user.

\begin{itemize}
\item \textbf{Create:} The method \textit{createCollection} requires two argument, namely the app name and the name of the new collection. This method creates automatically an empty index in the search engine, which can be later used for searching within this collection. The name of the created index is based on the name of the app combined with '\_' and the name of the collection, i.e if the name of the app is \textit{vod1} and the name of the collection is \textit{collection1}, the created index name would be \textit{vod1\_collection1}.

\item \textbf{Read:} The method \textit{listCollections} is for listing all collections within an app, see listing \ref{lst:listing_coll} for an example.

\begin{code}
\begin{minted}[frame=single]{console}
GET https://user1:pass@107.23.121.185:8080/cccd/app/vod1
/collections
\end{minted}
Response:
\begin{minted}[frame=single]{json}
{
"data":["collection1","collection2"],
"ok":"1"
}
\end{minted}
\caption{Listing all collections within an app}
\label{lst:listing_coll}
\end{code}

\item \textbf{Delete:} Deleting a collection would delete the entire data in it and also delete its index in the Search Engine. Furthermore the data/files which are in the Content Distribution component, which belong to this collection will be deleted too.
\end{itemize}

\paragraph{Mapping Interface /app/{appName}/collections/{collectionName}/mapping :} Before adding data to any collection, fields should be mapped to a proper object, i.e. string, integer, date, array or geo\_point. 

cite http://www.elasticsearch.org/guide/reference/mapping/
Mapping is the process of defining how a document should be mapped to the Search Engine, including its searchable characteristics such as which fields are searchable and if/how they are tokenized.  By default, there is no need to define an explicit mapping, since one is automatically created and registered when a new type or new field is introduced and have sensible defaults. Only when the defaults need to be overridden must a mapping definition be provided. Only Get and Update are provided through this interface.
 
\begin{itemize}

\item \textbf{Read:} The method \textit{listAllMappings} takes as parameters the \textit{appName} and the \textit{collectionName} and returns the entire mapping list for this collection.

\begin{code}
\begin{minted}[frame=single]{console}
GET https://user1:pass@107.23.121.185:8080/cccd/app/vod1
/collections/collection1/mapping
\end{minted}
Payload:
\begin{minted}[frame=single]{json}
{
"data": {
	"sourceAsMap": {
		"properties": {
			"date": {
				"type": "date",
				"format": "dateOptionalTime"
				},
			"name": {
				"type": "string"
			},
			"owner": {
				"type": "string"
			}
		}
	}
},
"ok": "1"
}

\end{minted}
\end{code}

\item \textbf{Update:} The method \textit{updateMapping} takes as parameters the \textit{appName}, the \textit{collectionName} and the mapping description \textit{body} as payload in JSON format and allows to register specific mapping definition for a specific collection.

\begin{code}
\begin{minted}[frame=single]{console}
PUT https://user1:pass@107.23.121.185:8080/cccd/app/vod1
/collections/collection1/mapping
\end{minted}
Payload:
\begin{minted}[frame=single]{json}
{
	"collection1" : {
		"properties" : {
			"name" : {"type" : "string"}
		}
	}
}
\end{minted}
\end{code}

\end{itemize}


\paragraph{Document Interface /app/{appName}/collections/{collectionName}/doc :} The repository of the framework is a document-based database system, and as a result, all records, or data, in it are documents. Documents are the default representation of most user accessible data structures in the repository.

\begin{itemize}
\item \textbf{Create:} The method \textit{createDocument} takes as parameters  the \textit{appName}, \textit{collectionName} and  the document it self as payload in JSON format \textit{body} and saves this document in the repository and also in the search engine in order to make the document searchable.  

\begin{code}
\begin{minted}[frame=single]{console}
POST http://abdul:abdul@107.23.121.185:8080/cccd/app/vod1
/collections/collection1/doc
\end{minted}
Payload:
\begin{minted}[frame=single]{json}
{
"name":"video in Berlin",
"date":"2013-01-01T01:12:12",
"owner":"Tom"
}
\end{minted}
\end{code}


\item \textbf{Read:} The method \textit{getDocument} requires the \textit{appName}, \textit{collectionName} and an \textit{objectId} and returns the correspondent document. The example below shows how to get the document with the \textit{objectId} 512d3258e4b0acc3647858f2.

\begin{code}
\begin{minted}[frame=single]{console}
GET http://abdul:abdul@107.23.121.185:8080/cccd/app/vod1
/collections/collection1/doc/512d3258e4b0acc3647858f2
\end{minted}
Response:
\begin{minted}[frame=single]{json}
{
"data":{
	"_id":{
			"machine":-458183485,
			"timeSecond":1361916504,
			"inc":1685608690,
			"time":1361916504000,
			"new":false
	},
	"name":"video in Berlin",
	"owner":"Tom",
	"date":"2013-01-01T01:12:12"
},
"ok":"1"
}
\end{minted}
\end{code}

\item \textbf{Update:} The method \textit{updateDocument} requires the \textit{appName}, \textit{collectionName}, \textit{objectID} and the JSON formatted payload \textit{body}. The body contains  the fields, which needs to be updated within a document.

\begin{code}
\begin{minted}[frame=single]{console}
POST http://abdul:abdul@107.23.121.185:8080/cccd/app/vod1
/collections/collection1/doc/512d3258e4b0acc3647858f2
\end{minted}
Payload:
\begin{minted}[frame=single]{json}
{
"name":"video in Potsdam"
}
\end{minted}
\end{code}

\item \textbf{Delete:} The method \textit{deleteDocument} deletes the specific document from the repository and from the search engine too.

\begin{code}
\begin{minted}[frame=single]{console}
DELETE http://abdul:abdul@107.23.121.185:8080/cccd/app/vod1
/collections/collection1/doc/512d3258e4b0acc3647858f2
\end{minted}
\end{code}
 
\end{itemize}
\paragraph{Buckets Interface /app/{appName}/buckets :} Just like a bucket holds water, buckets - known in Amazon Web Services - are a container for files. The name of the bucket must be unique within an app. The four CRUD operations are described below.

\begin{itemize}
\item \textbf{Create:} The method \textit{createBucket} requires two parameters, namely the app name and the bucket name and it creates a bucket within an app. The following example is for creating a bucket name \textit{bucket1} within the app \textit{vod1}.

\begin{code}
\begin{minted}[frame=single]{console}
POST https://user1:pass@107.23.121.185:8080/cccd/app/vod1
/buckets/bucket1
\end{minted}
\end{code}


\item \textbf{Read:} Within buckets interface there are two methods, which can be consumed through a HTTP GET. The first method \textit{listBuckets} lists all buckets which belong to a specific app. 

\begin{code}
\begin{minted}[frame=single]{console}
GET https://user1:pass@107.23.121.185:8080/cccd/app/bookstore
/buckets
\end{minted}
\end{code}

The second method \textit{listAllFilesInBucket} takes as parameters the \textit{appName} and the \textit{bucketName} and lists all the files which are in bucket \textit{bucketName}.

\begin{code}
\begin{minted}[frame=single]{console}
GET https://user1:pass@107.23.121.185:8080/cccd/app/bookstore
/buckets/books
\end{minted}
\end{code}


\item \textbf{Delete:} The method \textit{deleteBucket} deletes a bucket along with its files from an app 

\begin{code}
\begin{minted}[frame=single]{console}
DELETE https://user1:pass@107.23.121.185:8080/cccd/app/bookstore
/buckets/books
\end{minted}
\end{code}

\end{itemize}

\paragraph{Files Interface /app/{appName}/buckets/{bucketName}/{filename} :}  This interface manages files within a buckets.

\begin{itemize}
\item {Create:} The method \textit{addFileToBucket} allows to upload a file to a bucket and it requires the parameters \textit{appName}, \textit{bucketName} and \textit{filename} along with the file its self.

\item {Read:} The method \textit{getFileFromBucket} allows to get a file from a bucket and it requires also the parameters \textit{appName}, \textit{bucketName} and \textit{filename}.  An example for downloading a file named \textit{test.pdf} from the bucket \textit{books} and app \textit{bookstore} is listed below.

\begin{code}
\begin{minted}[frame=single]{console}
GET https://user1:pass@107.23.121.185:8080/cccd/app/bookstore
/buckets/books/test.pdf
\end{minted}
\end{code}

\item {Update:} The method \textit{updateFileInBucket} allows to update a file within a bucket and it requires also the parameters \textit{appName}, \textit{bucketName}, \textit{filename} and the file its self.  The update here is theoretically removing the old file and then adding the new one.
\begin{code}
\begin{minted}[frame=single]{console}
PUT https://user1:pass@107.23.121.185:8080/cccd/app/bookstore
/buckets/books/test.pdf
\end{minted}
\end{code}

\item {Remove:} The method \textit{deleteFileFromBucket} deletes a file from a bucket.

\end{itemize}





\subsubsection{Informative Response:} In order to know if a request to the framework succeeded or failed, the API should always send a tag in each response which shows either the request processed successfully or not, i.e. {"ok":1} in case of success or {"ok":0} in case of failure. Furthermore a configuration parameter will be implemented to enable more debug information, i.e. while creating a new app, if its name exist already, then the response include the error as a string i.e. {"ok":0,"debug":"app name exist already"}.

\subsection{Repository / Media Store \label{sec:des_repo}}


\subsection{Search Engine\label{sec:des_se_en}}
\subsection{Content Adaptation\label{sec:des_ar_ov}}
\subsection{Content Distribution\label{sec:des_cdn}}	
	
	\subsection{Application Messaging\label{sec:des_me}}
	
	\subsection{User API\label{sec:des_api}}

\section{Interfaces\label{sec:des_inter}}

\section{Requirement Fulfillment\label{sec:des_inter}}